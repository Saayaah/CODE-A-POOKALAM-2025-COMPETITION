<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pookalam</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Malayalam&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #1a1a1a;
            overflow: hidden;
            font-family: 'Inter','Noto Sans Malayalam' , sans-serif;
        }
        canvas {
            display: block;
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.3);
        }
    </style>
</head>
<body>
<script>
let globalRotation = 0;
let rotationSpeed = 0.05;
let hueOffset = 0;
let targetHue = 0;

let particles = [];
let ripples = [];

function setup() {
  let canvasSize = min(windowWidth, windowHeight) * 0.95;
  createCanvas(canvasSize, canvasSize);
  angleMode(DEGREES);
  colorMode(HSB, 360, 100, 100, 100);
  noStroke();

  targetHue = random(360);
  hueOffset = targetHue;

  for (let i = 0; i < 150; i++) {
    particles.push(new Particle());
  }
}

function windowResized() {
    let canvasSize = min(windowWidth, windowHeight) * 0.95;
    resizeCanvas(canvasSize, canvasSize);
}

function mousePressed() {
    ripples.push(new Ripple());
}

function draw() {
  background(280, 10, 10); 

  if (frameCount > 0 && frameCount % 360 === 0) {
      targetHue = random(360);
  }

  hueOffset = lerp(hueOffset, targetHue, 0.02);
  globalRotation += rotationSpeed;
  
  let mouseDist = dist(mouseX, mouseY, width / 2, height / 2);
  let scaleFactor = map(mouseDist, 0, width / 2, 1.1, 0.9);
  let pulse = sin(frameCount * 1.5) * 4 + noise(frameCount * 0.05) * 5;

  for (let particle of particles) {
    particle.update();
    particle.draw();
  }

  translate(width / 2, height / 2);
  
  const baseRadius = width * 0.4; 

  drawGlowAuraRing(baseRadius * 0.95, pulse);
  drawOuterPetalLayer(baseRadius * 0.85, globalRotation * 1.1);
  drawWavyPetalLayer(baseRadius * 0.75, -globalRotation * 1.2, pulse);
  drawSunburstLayer(baseRadius * 0.7, globalRotation * 1.5);
  drawLotusBudLayer(baseRadius * 0.65, -globalRotation * 1.8, pulse);
  drawLayeredGreenLeaves(baseRadius * 0.58, globalRotation * 2.2);
  drawConchSpiralLayer(baseRadius * 0.6, -globalRotation * 0.5);
  drawInnerPetalDustRing(baseRadius * 0.48);
  drawPeacockFeatherRing(baseRadius * 0.42, globalRotation * 2.5);
  drawBeadLayer(baseRadius * 0.38, -globalRotation * 2.8, pulse);
  drawChainLinkLayer(baseRadius * 0.35, globalRotation * 3.2);
  drawMandalaLaceLayer(baseRadius * 0.3, -globalRotation * 3.5);
  drawKolamCenter(baseRadius * 0.2, globalRotation * 4);
  drawStarFlowerCenter(baseRadius * 0.1, -globalRotation * 5, pulse);

  for (let i = ripples.length - 1; i >= 0; i--) {
    let ripple = ripples[i];
    ripple.update();
    ripple.draw();
    if (ripple.isFinished()) {
      ripples.splice(i, 1);
    }
  }

  resetMatrix();
  drawOnamGreeting();
  
  fill(60, 0, 90, 80);
  textAlign(RIGHT, BOTTOM);
  textSize(width * 0.015);
  text("Made By Sayanth", width - 20, height - 35);
  textSize(width * 0.012);
  text("www.linkedin.com/in/sayanthkrishnaks", width - 20, height - 20);
}

class Particle {
  constructor() {
    this.pos = createVector(random(width), random(height));
    this.vel = p5.Vector.random2D().mult(random(0.2, 0.8));
    this.lifespan = 255;
    this.size = random(1, 4);
  }

  update() {
    this.pos.add(this.vel);
    this.lifespan -= 0.8;
    if (this.pos.x > width) this.pos.x = 0;
    if (this.pos.x < 0) this.pos.x = width;
    if (this.pos.y > height) this.pos.y = 0;
    if (this.pos.y < 0) this.pos.y = height;
  }

  draw() {
    noStroke();
    fill((hueOffset + 45) % 360, 80, 100, this.lifespan / 3);
    ellipse(this.pos.x, this.pos.y, this.size);
  }
}

class Ripple {
  constructor() {
    this.radius = 0;
    this.maxRadius = width * 0.6;
    this.lifespan = 100;
  }

  update() {
    this.radius += 5;
    this.lifespan -= 2;
  }

  draw() {
    noFill();
    strokeWeight(map(this.lifespan, 100, 0, 1, 4));
    stroke((hueOffset + 180) % 360, 80, 100, this.lifespan);
    circle(0, 0, this.radius * 2);
  }
    
  isFinished() {
    return this.lifespan <= 0;
  }
}

function drawOnamGreeting() {
  fill(30, 90, 100);
  textSize(width * 0.03);
  textAlign(CENTER, TOP);
  text("ഓണം ആശംസകൾ", width / 2, 20);
}

function drawGlowAuraRing(radius, pulse) {
  for (let r = radius + pulse; r < radius + pulse + width * 0.07; r += 4) {
    let alpha = map(r, radius, radius + width * 0.07, 40, 0);
    fill((hueOffset + 50) % 360, 100, 100, alpha);
    circle(0, 0, r * 2);
  }
}

function drawOuterPetalLayer(radius, rotation) {
  let petalCount = 28;
  push();
  rotate(rotation);
  for (let i = 0; i < petalCount; i++) {
    let angle = (360 / petalCount) * i;
    push();
    rotate(angle);
    let r = radius;
    fill(0, 0, 0, 10);
    push();
    translate(3, 3);
    beginShape();
    vertex(r - r*0.2, 0); bezierVertex(r, -r*0.2, r + r*0.07, -r*0.15, r + r*0.2, 0); bezierVertex(r + r*0.07, r*0.15, r, r*0.2, r-r*0.2, 0);
    endShape(CLOSE);
    pop();
    for (let j = 0; j < 9; j++) {
        let rOffset = j * (radius * 0.015);
        let grad = map(j, 0, 8, 0.9, 0);
        let h = lerp(15, 55, grad);
        fill((h + hueOffset) % 360, 90, 100);
        beginShape();
        vertex(r - r*0.2 - rOffset, 0); bezierVertex(r - rOffset, -r*0.2, r + r*0.07 - rOffset, -r*0.15, r + r*0.2 - rOffset, 0); bezierVertex(r + r*0.07 - rOffset, r*0.15, r - rOffset, r*0.2, r - r*0.2 - rOffset, 0);
        endShape(CLOSE);
    }
    pop();
  }
  pop();
}

function drawWavyPetalLayer(radius, rotation, pulse) {
  let petalCount = 48;
  push();
  rotate(rotation);
  for (let i = 0; i < petalCount; i++) {
    let angle = (360 / petalCount) * i;
    push();
    rotate(angle);
    fill(i % 2 === 0 ? (hueOffset + 340) % 360 : (hueOffset + 55) % 360, 60, 100);
    let r = radius + pulse;
    beginShape();
    vertex(r, 0); bezierVertex(r - r*0.05, -r*0.15, r + r*0.2, -r*0.1, r + r*0.25, 0); bezierVertex(r + r*0.2, r*0.1, r - r*0.05, r*0.15, r, 0);
    endShape(CLOSE);
    pop();
  }
  pop();
}

function drawSunburstLayer(radius, rotation) {
  let rayCount = 48;
  push();
  rotate(rotation);
  for (let i = 0; i < rayCount; i++) {
    let angle = (360 / rayCount) * i;
    push();
    rotate(angle);
    fill((hueOffset + 30) % 360, 100, 100);
    triangle(radius - radius*0.1, 0, radius + radius*0.1, 0, radius, -radius*0.15);
    pop();
  }
  pop();
}

function drawLotusBudLayer(radius, rotation, pulse) {
  let budCount = 60;
  push();
  rotate(rotation);
  for (let i = 0; i < budCount; i++) {
    let angle = (360 / budCount) * i;
    push();
    rotate(angle);
    fill((hueOffset + 280) % 360, 70, 80);
    ellipse(radius + pulse, 0, radius * 0.2, radius * 0.1);
    fill(0, 0, 100, 50);
    ellipse(radius - radius*0.025 + pulse, -radius*0.025, radius*0.075, radius*0.04);
    pop();
  }
  pop();
}

function drawLayeredGreenLeaves(radius, rotation) {
    let leafCount = 60;
    push();
    rotate(rotation);
    for (let i = 0; i < leafCount; i++) {
        let angle = (360 / leafCount) * i;
        push();
        rotate(angle);
        fill(0, 0, 0, 10);
        push();
        translate(2, 2);
        beginShape();
        vertex(radius, 0); bezierVertex(radius*0.9, -radius*0.15, radius*1.15, -radius*0.15, radius*1.2, 0); bezierVertex(radius*1.15, radius*0.15, radius*0.9, radius*0.15, radius, 0);
        endShape(CLOSE);
        pop();
        fill((hueOffset + (i % 2 === 0 ? 140 : 150)) % 360, 60, 65);
        beginShape();
        vertex(radius, 0); bezierVertex(radius*0.9, -radius*0.15, radius*1.15, -radius*0.15, radius*1.2, 0); bezierVertex(radius*1.15, radius*0.15, radius*0.9, radius*0.15, radius, 0);
        endShape(CLOSE);
        pop();
    }
    pop();
}

function drawConchSpiralLayer(radius, rotation) {
  noFill();
  strokeWeight(2);
  stroke((hueOffset + 260) % 360, 80, 100);
  push();
  rotate(rotation);
  for (let i = 0; i < 12; i++) {
    let angle = (360 / 12) * i;
    push();
    rotate(angle);
    beginShape();
    for (let t = 0; t < 180; t += 10) {
      let r = radius * 0.7 + t * 0.2;
      let x = r * cos(t);
      let y = r * sin(t);
      vertex(x, y);
    }
    endShape();
    pop();
  }
  pop();
  noStroke();
}

function drawInnerPetalDustRing(maxRadius) {
  for (let i = 0; i < 1500; i++) { 
    let radius = random(maxRadius * 0.8, maxRadius);
    let angle = random(360);
    let x = radius * cos(angle);
    let y = radius * sin(angle);
    stroke(random() > 0.5 ? (hueOffset + 270) % 360 : (hueOffset + 280) % 360, 60, 85);
    point(x, y);
  }
  noStroke();
}

function drawPeacockFeatherRing(radius, rotation) {
  let featherCount = 24;
  push();
  rotate(rotation);
  for (let i = 0; i < featherCount; i++) {
    let angle = (360 / featherCount) * i;
    let x = radius * cos(angle);
    let y = radius * sin(angle);
    push();
    translate(x, y);
    rotate(angle + 90);
    fill((hueOffset + 210) % 360, 80, 100);
    ellipse(0, 0, radius * 0.3, radius * 0.5);
    fill((hueOffset + 55) % 360, 100, 100);
    ellipse(0, -radius*0.07, radius*0.15, radius*0.22);
    fill((hueOffset + 150) % 360, 100, 60);
    circle(0, -radius*0.07, radius*0.07);
    pop();
  }
  pop();
}

function drawBeadLayer(radius, rotation, pulse) {
  let beadCount = 80;
  push();
  rotate(rotation);
  for (let i = 0; i < beadCount; i++) {
    let angle = (360 / beadCount) * i;
    let r = radius + pulse;
    let x = r * cos(angle);
    let y = r * sin(angle);
    fill((hueOffset + 55) % 360, 100, 100);
    circle(x, y, radius*0.1);
    fill(60, 20, 100, 80);
    circle(x - 2, y - 2, radius*0.03);
  }
  pop();
}

function drawChainLinkLayer(radius, rotation) {
  stroke((hueOffset + 35) % 360, 60, 80);
  strokeWeight(2);
  noFill();
  let linkCount = 48;
  push();
  rotate(rotation);
  for (let i = 0; i < linkCount; i++) {
    let angle = (360 / linkCount) * i;
    push();
    rotate(angle);
    arc(radius, 0, radius*0.2, radius*0.2, -120, 120);
    pop();
  }
  pop();
  noStroke();
}

function drawMandalaLaceLayer(radius, rotation) {
  stroke((hueOffset + 45) % 360, 70, 85);
  noFill();
  let laceCount = 36;
  push();
  rotate(rotation);
  for (let i = 0; i < laceCount; i++) {
    let angle = (360 / laceCount) * i;
    let x = radius * cos(angle);
    let y = radius * sin(angle);
    push();
    translate(x, y);
    rotate(angle);
    ellipse(0, 0, radius*0.2, radius*0.4);
    pop();
  }
  pop();
  noStroke();
}

function drawKolamCenter(radius, rotation) {
  noFill();
  push();
  rotate(rotation);
  let circleCount = 12;
  
  strokeWeight(3);
  stroke((hueOffset + 160) % 360, 80, 60);
  for (let i = 0; i < circleCount; i++) {
    let angle = (360 / circleCount) * i;
    let x = radius * 0.7 * cos(angle);
    let y = radius * 0.7 * sin(angle);
    circle(x, y, radius);
  }

  strokeWeight(1.5);
  stroke((hueOffset + 55) % 360, 100, 100);
  for (let i = 0; i < circleCount; i++) {
    let angle = (360 / circleCount) * i;
    push(); rotate(angle + 15); arc(0, 0, radius * 0.8, radius * 0.8, -40, 40); arc(0, 0, radius * 1.5, radius * 1.5, -20, 20); pop();
  }

  strokeWeight(1);
  stroke((hueOffset + 0) % 360, 80, 90);
  for (let i = 0; i < 24; i++) {
    let angle = (360 / 24) * i;
    line(0, 0, radius * 1.1 * cos(angle), radius * 1.1 * sin(angle));
  }

  strokeWeight(4);
  stroke(0, 0, 100, 80);
  for (let i = 0; i < circleCount; i++) {
    let angle = (360 / circleCount) * i;
    push(); rotate(angle); arc(0, 0, radius * 1.2, radius * 1.2, -35, 35); pop();
  }
  pop();
  noStroke();
}

function drawStarFlowerCenter(radius, rotation, pulse) {
  let pointCount = 8;
  push();
  rotate(rotation);
  fill((hueOffset + 15) % 360, 100, 100);
  beginShape();
  for (let i = 0; i < pointCount * 2; i++) {
    let r = i % 2 === 0 ? radius + pulse : (radius * 0.4) + pulse;
    let angle = (360 / (pointCount * 2)) * i;
    vertex(r * cos(angle), r * sin(angle));
  }
  endShape(CLOSE);
  fill((hueOffset + 55) % 360, 100, 100);
  circle(0, 0, (radius * 0.3) + pulse / 2);
  pop();
}

</script>
</body>
</html>




